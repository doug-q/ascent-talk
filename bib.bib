@inproceedings{ascent1,
author = {Sahebolamri, Arash and Gilray, Thomas and Micinski, Kristopher},
title = {Seamless deductive inference via macros},
year = {2022},
isbn = {9781450391832},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3497776.3517779},
doi = {10.1145/3497776.3517779},
abstract = {We present an approach to integrating state-of-art bottom-up logic programming within the Rust ecosystem, demonstrating it with Ascent, an extension of Datalog that performs well against comparable systems. Rust’s powerful macro system permits Ascent to be compiled uniformly with the Rust code it’s embedded in and to interoperate with arbitrary user-defined components written in Rust, addressing a challenge in real-world use of logic programming languages: the fact that logical programs are parts of bigger software systems and need to interoperate with other components written in imperative programming languages. We leverage Rust’s trait system to extend Datalog semantics with non-powerset lattices, much like Flix, and with user-defined data types much like Formulog and Souffle. We use Ascent to re-implement the Rust borrow checker, a static analysis required by the Rust compiler. We evaluate our performance against Datafrog, Flix, and Souffl\'{e} using the borrow checker and other benchmarks, observing comparable performance to Datafrog and Souffl\'{e}, and speedups of around two orders of magnitude compared to Flix.},
booktitle = {Proceedings of the 31st ACM SIGPLAN International Conference on Compiler Construction},
pages = {77–88},
numpages = {12},
keywords = {Static Analysis, Rust, Program Analysis, Logic Programming, Datalog, Ascent},
location = {Seoul, South Korea},
series = {CC 2022}
}
@article{Horn_1951, title={On sentences which are true of direct unions of algebras}, volume={16}, DOI={10.2307/2268661}, number={1}, journal={Journal of Symbolic Logic}, author={Horn, Alfred}, year={1951}, pages={14–21}}A
@article{10.1145/3622840,
author = {Sahebolamri, Arash and Barrett, Langston and Moore, Scott and Micinski, Kristopher},
title = {Bring Your Own Data Structures to Datalog},
year = {2023},
issue_date = {October 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {OOPSLA2},
url = {https://doi.org/10.1145/3622840},
doi = {10.1145/3622840},
abstract = {The restricted logic programming language Datalog has become a popular implementation target for deductive-analytic workloads including social-media analytics and program analysis. Modern Datalog engines compile Datalog rules to joins over explicit representations of relations—often B-trees or hash maps. While these modern engines have enabled high scalability in many application domains, they have a crucial weakness: achieving the desired algorithmic complexity may be impossible due to representation-imposed overhead of the engine’s data structures. In this paper, we present the "Bring Your Own Data Structures" (Byods) approach, in the form of a DSL embedded in Rust. Using Byods, an engineer writes logical rules which are implicitly parametric on the concrete data structure representation; our implementation provides an interface to enable "bringing their own" data structures to represent relations, which harmoniously interact with code generated by our compiler (implemented as Rust procedural macros). We formalize the semantics of Byods as an extension of Datalog’s; our formalization captures the key properties demanded of data structures compatible with Byods, including properties required for incrementalized (semi-na\"{\i}ve) evaluation. We detail many applications of the Byods approach, implementing analyses requiring specialized data structures for transitive and equivalence relations to scale, including an optimized version of the Rust borrow checker Polonius; highly-parallel PageRank made possible by lattices; and a large-scale analysis of LLVM utilizing index-sharing to scale. Our results show that Byods offers both improved algorithmic scalability (reduced time and/or space complexity) and runtimes competitive with state-of-the-art parallelizing Datalog solvers.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {264},
numpages = {26},
keywords = {Static Analysis, Program Analysis, Logic Programming, Datalog}
}
@inproceedings{Jordan2016SoufflOS,
  title={Souffl{\'e}: On Synthesis of Program Analyzers},
  author={Herbert Jordan and Bernhard Scholz and Pavle Suboti{\'c}},
  booktitle={International Conference on Computer Aided Verification},
  year={2016},
  url={https://api.semanticscholar.org/CorpusID:7428346}
}
@inproceedings{10.1145/2892208.2892226,
author = {Scholz, Bernhard and Jordan, Herbert and Suboti\'{c}, Pavle and Westmann, Till},
title = {On fast large-scale program analysis in Datalog},
year = {2016},
isbn = {9781450342414},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2892208.2892226},
doi = {10.1145/2892208.2892226},
abstract = {Designing and crafting a static program analysis is challenging due to the complexity of the task at hand. Among the challenges are modelling the semantics of the input language, finding suitable abstractions for the analysis, and handwriting efficient code for the analysis in a traditional imperative language such as C++. Hence, the development of static program analysis tools is costly in terms of development time and resources for real world languages. To overcome, or at least alleviate the costs of developing a static program analysis, Datalog has been proposed as a domain specific language (DSL). With Datalog, a designer expresses a static program analysis in the form of a logical specification. While a domain specific language approach aids in the ease of development of program analyses, it is commonly accepted that such an approach has worse runtime performance than handcrafted static analysis tools. In this work, we introduce a new program synthesis methodology for Datalog specifications to produce highly efficient monolithic C++ analyzers. The synthesis technique requires the re-interpretation of the semi-naive evaluation as a scaffolding for translation using partial evaluation. To achieve high-performance, we employ staged-compilation techniques and specialize the underlying relational data structures for a given Datalog specification. Experimentation on benchmarks for large-scale program analysis validates the superior performance of our approach over available Datalog tools and demonstrates our competitiveness with state-of-the-art handcrafted tools.},
booktitle = {Proceedings of the 25th International Conference on Compiler Construction},
pages = {196–206},
numpages = {11},
keywords = {Compiler, Datalog, Program Synthesis, Static Program Analysis},
location = {Barcelona, Spain},
series = {CC 2016}
}
@misc{HugrDatalog,
  title = {Hugr is a Database},
  howpublished = {\url{https://cqc.atlassian.net/wiki/spaces/~7120202999f23282ba4e99beaec8c17040a9ad/pages/2917007388/HUGR+is+a+Database}},
  author = {Heidemann}
}
